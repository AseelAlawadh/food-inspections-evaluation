
# Experiments with glmnet fits


## Load data (hidden:)

```{r, echo=FALSE, warning=FALSE, results='hide', message=FALSE}
stop()

##==============================================================================
## INITIALIZE
##==============================================================================
## Remove all objects; perform garbage collection
rm(list=ls())
gc(reset=TRUE)
## Check for dependencies
if(!"geneorama" %in% rownames(installed.packages())){
    if(!"devtools" %in% rownames(installed.packages())){install.packages('devtools')}
    devtools::install_github('geneorama/geneorama')}
## Load libraries
geneorama::detach_nonstandard_packages()
# geneorama::loadinstall_libraries(c("geneorama", "data.table"))
geneorama::loadinstall_libraries(c("data.table", "glmnet", "ggplot2", "caret"))
geneorama::sourceDir("CODE/functions/")

##==============================================================================
## DEFINE GLOBAL VARIABLES / MANUAL CODE
##==============================================================================
DataDir <- "DATA/20141110"

##==============================================================================
## LOAD CACHED RDS FILES
##==============================================================================
dat <- readRDS(file.path(DataDir, "dat_with_inspector.Rds"))
## Remove NA's
dat[,.N,is.na(heat_burglary)]
dat <- dat[!is.na(heat_burglary)]
## Add criticalFound variable to dat:
dat[ , criticalFound := pmin(1, criticalCount)]
## Set the key for dat
setkey(dat, Inspection_ID)
## Match time period of original results
# dat <- dat[Inspection_Date < "2013-09-01" | Inspection_Date > "2014-07-01"]
dat[, .N, Results]
## Remove records where an inspection didn't happen
dat <- dat[!Results %in% c('Out of Business','Business Not Located','No Entry')]
```


## Define the model matrix

```{r}
##==============================================================================
## CREATE MODEL DATA
##==============================================================================
# sort(colnames(dat))
xmat <- dat[ , list(criticalFound,
                    Inspector_Assigned,
                    pastSerious = pmin(pastSerious, 1),
                    ageAtInspection = ifelse(ageAtInspection > 4, 1L, 0L),
                    pastCritical = pmin(pastCritical, 1),
                    consumption_on_premises_incidental_activity,
                    tobacco_retail_over_counter,
                    temperatureMax,
                    heat_burglary = pmin(heat_burglary, 70),
                    heat_sanitation = pmin(heat_sanitation, 70),
                    heat_garbage = pmin(heat_garbage, 50),
                    # risk = as.factor(Risk),
                    # facility_type = as.factor(Facility_Type),
                    timeSinceLast),
            keyby = Inspection_ID]
mm <- model.matrix(criticalFound ~ . -1, data=xmat[ , -1, with=F])
mm <- as.data.table(mm)
str(mm)
colnames(mm)
```

### Including Eval partition again

```{r}
##==============================================================================
## CREATE TEST / TRAIN / EVAL PARTITIONS
##==============================================================================
## 2014-07-01 is an easy separator
dat[Inspection_Date < "2014-07-01", range(Inspection_Date)]
dat[Inspection_Date > "2014-07-01", range(Inspection_Date)]

iiNonEval <- dat[ , which(Inspection_Date < "2014-07-01")]
NonEvalSplit <- createDataPartition(y = dat[iiNonEval, criticalFound],
                                    times = 1,
                                    p = .9,
                                    list = TRUE)
iiTrain <- iiNonEval[NonEvalSplit$Resample1]
iiTest <- iiNonEval[-NonEvalSplit$Resample1]
iiEval <- dat[ , which(Inspection_Date > "2014-07-01")]

yyTrain <- dat[iiTrain, criticalFound]
yyTest <- dat[iiTest, criticalFound]
yyEval <- dat[iiEval, criticalFound]
```



```{r, echo=FALSE}
## NOT FINISHED!

##==============================================================================
## GLMNET MODEL FUNCTION
##==============================================================================

# wrapper <- function(x = as.matrix(mm[iiTrain]),
#                     y = xmat[iiTrain,  criticalFound],
#                     pen = ifelse(grepl("^Inspector.Assigned", colnames(mm)), 1, 0),
#                    
#                     ){
#     # fit ridge regression, alpha = 0, only inspector coefficients penalized
#     m0 <- glmnet(x=x, y=y, family="binomial",  alpha=0, penalty.factor = pen)
#     ## manual lambda selection
#     w.lam <- 100
#     lam <- m0$lambda[w.lam]
#     coef <- m0$beta[,w.lam]
#     inspCoef <- coef[grepl("^Inspector.Assigned",names(coef))]
#     inspCoef <- inspCoef[order(-inspCoef)]
#    
#     m0$pred <- predict(m0, newx=as.matrix(mm), s=lam, type="response")[,1]
#     m0$predTest <- m0$pred[iiTest]
#     m0$predTest <- m0$pred[iiTest]
#    
#    
#     ## coefficients for the inspectors, and for other variables
#     inspCoef
#     coef[!grepl("^Inspector.Assigned",names(coef))]
#    
#     inspectors <- gsub("Inspector_Assigned", "", names(inspCoef))
#     inspectors
#     as.numeric(cut(inspCoef, hist(inspCoef, plot=F)$breaks))
#    
# }
```



## Try some different assumptions in the model

```{r}
##==============================================================================
## GLMNET MODELS
##==============================================================================
# fit ridge regression, alpha = 0, only inspector coefficients penalized
pen <- ifelse(grepl("^Inspector.Assigned", colnames(mm)), 1, 0)
m0 <- glmnet(x = as.matrix(mm[iiTrain]),
             y = xmat[iiTrain,  criticalFound],
             family = "binomial",
             alpha = 0,
             penalty.factor = pen)
m1 <- glmnet(x = as.matrix(mm[iiTrain]),
             y = xmat[iiTrain,  criticalFound],
             family = "binomial",
             penalty.factor = pen)
m2 <- glmnet(x = as.matrix(mm[iiTrain]),
             y = xmat[iiTrain,  criticalFound],
             family = "binomial",
             alpha = 0)
m3 <- glmnet(x = as.matrix(mm[iiTrain]),
             y = xmat[iiTrain,  criticalFound],
             family = "binomial")

mcv0 <- cv.glmnet(x=as.matrix(mm[iiTrain]), y=xmat[iiTrain,  criticalFound],
                  family = "binomial", alpha=0, penalty.factor=pen)
mcv1 <- cv.glmnet(x=as.matrix(mm[iiTrain]),y=xmat[iiTrain,  criticalFound],
                  family = "binomial", penalty.factor=pen)
mcv2 <- cv.glmnet(x=as.matrix(mm[iiTrain]), y=xmat[iiTrain,  criticalFound],
                  family = "binomial", alpha=0)
mcv3 <- cv.glmnet(x=as.matrix(mm[iiTrain]), y=xmat[iiTrain,  criticalFound],
                  family = "binomial")
```

### Cross validated lambda selection

```{r}
### Looking at the error selection
par(mfrow=c(2,2))
plot(mcv0, main="alpha=0 & penalty")
plot(mcv1, main="penalty")
plot(mcv2, main="alpha=0")
plot(mcv3, main="NULL")
par(mfrow=c(1,1))

mcv0[c("lambda.min", "lambda.1se")]
mcv1[c("lambda.min", "lambda.1se")]
mcv2[c("lambda.min", "lambda.1se")]
mcv3[c("lambda.min", "lambda.1se")]
```

### Convergence of coefficients for single models

```{r}
# colnames(mm)
# geneorama::plot100colors(100)
COL <- c(rep("cyan", 44),             # "Inspector_Assigned"
         "orange", "green",           # "pastSerious", "ageAtInspection"
         "red", "blue4",              # "pastCritical", "consumption_on_premises_incidental_activity"
         "darkorange4", "darkgreen",  # "tobacco_retail_over_counter", "temperatureMax"
         "gold", "gold3",             # "heat_burglary", "heat_sanitation"
         "gold4", "gray4")            #"heat_garbage", "timeSinceLast"
par(mfrow=c(2,2))
plot(m0, main="alpha=0, with penalty", col=COL)
plot(m1, main="with penalty", col=COL)
plot(m2, main="alpha=0", col=COL)
plot(m3, main="NULL", col=COL)
par(mfrow=c(1,1))
```

## Reconciling the error from the model 

```{r}
errorsTest <- sapply(m0$lambda,
                     function(lam)
                         logLik(p = predict(m0,
                                            newx = as.matrix(mm[iiTest]),
                                            s=lam,
                                            type="response")[,1],
                                y = xmat[iiTest, criticalFound]))
errorsTrain <- sapply(m0$lambda,
                      function(lam)
                          logLik(p = predict(m0,
                                             newx = as.matrix(mm[iiTrain]),
                                             s=lam,
                                             type="response")[,1],
                                 y = xmat[iiTrain, criticalFound]))
## Using the model outputs to recreate the "errorsTrain" variable
plot(errorsTrain)
lines(m0$nulldev/2-m0$nulldev/2*m0$dev.ratio)

## Using the function "deviance" instead of "errorsTrain"
plot(errorsTrain)
lines(deviance(m0)/2, col="blue")

## Using the "errorsTrain" variable to recreate the model outputs
plot(m0$dev.ratio)
lines((m0$nulldev/2-errorsTrain)/(m0$nulldev/2))
```

## Comparing cross validated dev.ratio values

```{r}
par(mfrow=c(2,2))
plot(mcv0$glmnet.fit$dev.ratio)
plot(mcv1$glmnet.fit$dev.ratio)
plot(mcv2$glmnet.fit$dev.ratio)
plot(mcv3$glmnet.fit$dev.ratio)
par(mfrow=c(1,1))
```


### Plots of dev.ratio for each model (together)

```{r}

log(mcv0$lambda)
dev_ratios_CV <- rbindlist(list(
    data.table(dev.ratio=mcv0$glmnet.fit$dev.ratio, loglambda=log(mcv0$lambda), model="mcv0"),
    data.table(dev.ratio=mcv1$glmnet.fit$dev.ratio, loglambda=log(mcv1$lambda), model="mcv1"),
    data.table(dev.ratio=mcv2$glmnet.fit$dev.ratio, loglambda=log(mcv2$lambda), model="mcv2"),
    data.table(dev.ratio=mcv3$glmnet.fit$dev.ratio, loglambda=log(mcv3$lambda), model="mcv3")))
dev_ratios_CV[,i:=1:.N,model]
dev_ratios_CV[,.N,model]
ggplot(dev_ratios_CV) +aes(x=loglambda,y=dev.ratio,colour=model) + geom_point()


# plot(mcv0$glmnet.fit$dev.ratio~log(mcv0$glmnet.fit$lambda), main="mcv0")
# plot(mcv1$glmnet.fit$dev.ratio~log(mcv1$glmnet.fit$lambda), main="mcv1")
# plot(mcv2$glmnet.fit$dev.ratio~log(mcv2$glmnet.fit$lambda), main="mcv2")
# plot(mcv3$glmnet.fit$dev.ratio~log(mcv3$glmnet.fit$lambda), main="mcv3")

```



```{r}
lambdaPredMatrix_m0 <- sapply(m0$lambda, function(lam)
    predict(m0, newx = as.matrix(mm), s=lam, type="response")[,1])
lambdaPredMatrix_m1 <- sapply(m1$lambda, function(lam)
    predict(m1, newx = as.matrix(mm), s=lam, type="response")[,1])
lambdaPredMatrix_m2 <- sapply(m2$lambda, function(lam)
    predict(m2, newx = as.matrix(mm), s=lam, type="response")[,1])
lambdaPredMatrix_m3 <- sapply(m3$lambda, function(lam)
    predict(m3, newx = as.matrix(mm), s=lam, type="response")[,1])

model_auc_values_train <- rbindlist(list(
    data.table(auc = apply(lambdaPredMatrix_m0[iiTrain, ], 2, glmnet:::auc, y=yyTrain), 
               loglambda = log(m0$lambda), 
               model = "m0"),
    data.table(auc = apply(lambdaPredMatrix_m1[iiTrain, ], 2, glmnet:::auc, y=yyTrain), 
               loglambda = log(m1$lambda), 
               model = "m1"),
    data.table(auc = apply(lambdaPredMatrix_m2[iiTrain, ], 2, glmnet:::auc, y=yyTrain), 
               loglambda = log(m2$lambda), 
               model = "m2"),
    data.table(auc = apply(lambdaPredMatrix_m3[iiTrain, ], 2, glmnet:::auc, y=yyTrain), 
               loglambda = log(m3$lambda), 
               model = "m3")
    ))
model_auc_values_eval <- rbindlist(list(
    data.table(auc = apply(lambdaPredMatrix_m0[iiEval, ], 2, glmnet:::auc, y=yyEval), 
               loglambda = log(m0$lambda), 
               model = "m0"),
    data.table(auc = apply(lambdaPredMatrix_m1[iiEval, ], 2, glmnet:::auc, y=yyEval), 
               loglambda = log(m1$lambda), 
               model = "m1"),
    data.table(auc = apply(lambdaPredMatrix_m2[iiEval, ], 2, glmnet:::auc, y=yyEval), 
               loglambda = log(m2$lambda), 
               model = "m2"),
    data.table(auc = apply(lambdaPredMatrix_m3[iiEval, ], 2, glmnet:::auc, y=yyEval), 
               loglambda = log(m3$lambda), 
               model = "m3")
    ))
ggplot(model_auc_values_train) + 
    aes(loglambda, auc, colour=model) + 
    geom_point()
ggplot(model_auc_values_eval) + 
    aes(loglambda, auc, colour=model) + 
    geom_point()
```


```{r}
lambdaPredMatrix <- lambdaPredMatrix_m0

iEval <- trunc(seq(1, length(yyEval), length.out=100))
iTest <- trunc(seq(1, length(yyTest), length.out=100))
iTrain <- trunc(seq(1, length(yyTrain), length.out=100))

lambdaRowMeans <- apply(lambdaPredMatrix, 1, mean)
# iiLambda <- order(-lambdaRowMeans)
iiLambda <- order(-lambdaPredMatrix[,100])
iiLambdaTrain <- order(-lambdaPredMatrix[iiTrain, 100])
iiLambdaTest  <- order(-lambdaPredMatrix[iiTest,  100])
iiLambdaEval  <- order(-lambdaPredMatrix[iiEval,  100])

plot(lambdaRowMeans[order(lambdaRowMeans)], ylim=range(lambdaPredMatrix), type="l")
plot(lambdaPredMatrix[,100][order(lambdaRowMeans)], ylim=range(lambdaPredMatrix), type="l")
plot(lambdaRowMeans[order(lambdaPredMatrix[,100])], ylim=range(lambdaPredMatrix), type="l")

ii <- iEval
plot(x = (1:length(ii))/length(ii),
     y = (cumsum(yyEval[iiLambdaEval]) / sum(yyEval[iiLambdaEval]))[ii] )
ii <- iTest
lines(x = (1:length(ii))/length(ii),
     y = (cumsum(yyEval[iiLambdaEval]) / sum(yyEval[iiLambdaEval]))[ii], col="red")
ii <- iTrain
lines(x = (1:length(ii))/length(ii),
     y = (cumsum(yyEval[iiLambdaEval]) / sum(yyEval[iiLambdaEval]))[ii], col="blue")

plot(diff(cumsum(yyEval[iiLambdaEval])[iEval]), type="o")
plot(diff(cumsum(yyTest[iiLambdaTest])[iTest]), type="o")
plot(diff(cumsum(yyTrain[iiLambdaTrain])[iTrain]), type="o")

m0$pred <- predict(m0, newx=as.matrix(mm), s=rev(m0$lambda)[1], type="response")[,1]
m1$pred <- predict(m1, newx=as.matrix(mm), s=rev(m1$lambda)[1], type="response")[,1]
m2$pred <- predict(m2, newx=as.matrix(mm), s=rev(m2$lambda)[1], type="response")[,1]
m3$pred <- predict(m3, newx=as.matrix(mm), s=rev(m3$lambda)[1], type="response")[,1]
#     m0$predTest <- m0$pred[iiTest]
#     m0$predTest <- m0$pred[iiTest]

boxplot(m0$pred[iiEval]~c("no violation", "critical violation")[yyEval+1])
boxplot(m1$pred[iiEval]~c("no violation", "critical violation")[yyEval+1])
boxplot(m2$pred[iiEval]~c("no violation", "critical violation")[yyEval+1])
boxplot(m3$pred[iiEval]~c("no violation", "critical violation")[yyEval+1])

```

```{r}
# ## manual lambda selection
# w.lam <- 100
# lam <- m0$lambda[w.lam]
# coef <- m0$beta[,w.lam]
# inspCoef <- coef[grepl("^Inspector.Assigned",names(coef))]
# inspCoef <- inspCoef[order(-inspCoef)]
# 
# m0$pred <- predict(m0, newx=as.matrix(mm), s=lam, type="response")[,1]
# m0$predTest <- m0$pred[iiTest]
# m0$predTest <- m0$pred[iiTest]
# 
# 
# ## coefficients for the inspectors, and for other variables
# inspCoef
# coef[!grepl("^Inspector.Assigned",names(coef))]
# 
# inspectors <- gsub("Inspector_Assigned", "", names(inspCoef))
# inspectors
# as.numeric(cut(inspCoef, hist(inspCoef, plot=F)$breaks))
```
